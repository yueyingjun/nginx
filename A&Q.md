## 1. 关于python语法问题111111111
1. python里面的推导式
> 推导式语法是Python语言有一种独特的语法，相当于语法糖的存在，可以帮你在某些场合写出比较精简酷炫的代码。但没有它，也不会有太多的影响。
- 列表推导式
    > 列表推导式其形式是用方括号括起来的一段语句,是一种快速生成列表的方式
    ```
    循环1-10的数字，并且将每一个数字平方：
    推导式写法:
    lis = [x * x for x in range(1, 10)]
    正常循环写法:
    lis=[]
    for x in range(1,10):
        lis.append(x*x)

    print(lis)
    ------------------------------------
    结果：[1, 4, 9, 16, 25, 36, 49, 64, 81]
    ```
    > 列表推导条件语句用法
    ```
    循环1-10的数字，取得偶数并且将每一个数字平方
    推导式写法:
    lis=[x * x for x in range(1, 11) if x % 2 == 0]
    正常循环写法:
    lis=[]
    for x in range(1,10):
        if (x%2==0):
            lis.append(x*x)
    print(lis)
    -----------------------
    [4, 16, 36, 64, 100]
    ```
- 字典推导式
    > 使用中括号[]可以编写列表推导式，那么使用大括号{}可以制造字典推导式！
    ```
    dic = {x: x**2 for x in (2, 4, 6)}
    print(dic)
    -------------------------
    {2: 4, 4: 16, 6: 36}

    print(type(dic))
    ------------------------
    <class 'dict'>

    ```
    **
    注意：x: x**2的写法，中间的冒号，表示最终生成的字典结构，左边的是key右边的是value
    **

- 集合推导式
    > 大括号除了能用作字典推导式，还可以用作集合推导式，两者仅仅在细微处有差别
    ```
    a = {x for x in 'abracadabra' if x not in 'abc'}
    print(a)
    ---------------------
    {'d', 'r'}
    ```
    **注意：因为集合没有键，所有在生成的结果中，不用使用 (键:值)的方式**

- 元组推导式?!
    > 那么用圆括号()括起来是不是元组推导式呢？不是！圆括号在Python中被用作生成器的语法了

    ```
    tup = (x for x in range(9))
    print(tup)
    print(type(tup))
    print(tuple(tup))

    ---------------------------
    结果：
    <generator object <genexpr> at 0x000000000255DA98>
    <class 'generator'>
    (0, 1, 2, 3, 4, 5, 6, 7, 8)
    ```
    **注意：用圆括号生成的是生成器，其结果直接能循环。要通过类似方法生成元组，需要显式调用元组的类型转换函数tuple()**

2. Python 容器、迭代对象、迭代器、生成器

- 容器
    > 容器比较容易理解，因为你就可以把它看作是一个盒子、一栋房子、一个柜子，里面可以塞任何东西。你可以将变量看做是一个容器
- 迭代对象
    > 能够进行循环，并且能够通过循环取到容器里面每个元素的容器就是迭代对象
    ```
    python内置的迭代对象:str,list,set,dict
    ```
- 迭代器
    > 能够创建迭代对象的工具，就叫迭代器
- 生成器
    > 生成器算得上是Python语言中最吸引人的特性之一，生成器其实是一种特殊的迭代器，不过这种迭代器更加优雅。只需要一个yiled关键字就可以，它的返回值不是通过return而是用yield
    > 生成器表达式  a = (x*x for x in range(10))

3. python的垃圾回收机制  (预解析)

    > python的垃圾回收机制主要采用，引用计数机制
- 引用计数机制：
    > python里每一个东西都是对象,每个对象内部有一个变量ob_refcnt,记录他的引用次数。当一个对象有新的引用时，它的引用数就会增加，当引用它的对象被删除，它的引用数就会减少。当引用计数为0时，该对象生命就结束了。

- 引用计数机制的优点：
    1. 简单: 不用采用其他语言复杂的算法
    2. 实时性：一旦没有引用，内存就直接释放了
- 引用计数机制的缺点：
    1. 维护引用计数消耗资源
    2. 循环引用,容易导致内存泄漏

## 2. 关于python框架的问题

1. flask以及django的区别
    > 这一问题的核心，是在考你是不是对这两个框架熟悉，以及你对程序的理解，没有标准答案。
- flask
    ```
    . Flask自由、灵活，可扩展性强，第三方库的选择面广，开发时  可以结合自己最喜欢用的轮子，也能结合最流行最强大的Python库
    . 入门简单，即便没有多少web开发经验，也能很快做出网站
    . 非常适用于小型网站
    . 非常适用于开发web服务的API
    . 各方面性能均等于或优于Django
    . 因为其足够的自由，很多代码得自己重构，工作量大，容易造成不稳定因素，没有django的稳定可靠
    ```
- django
    ```
    . Django太重了，除了web框架，自带ORM和模板引擎，灵活和自由度不够高
    . Django的自带ORM非常优秀，优于用原生的sql开发，不够灵活，不能够灵活的使用sql语句
    . Django自带的模板引擎简单好用
    . Django非常适合企业级网站的开发：快速、靠谱、稳定
    . Django成熟、稳定、完善，但相比于Flask，Django的整体生态相对封闭
    . Django是Python web框架的先驱，用户多，第三方库最丰富
    ```

2. 原生sql和orm有什么区别
    > 这主要是考你有没有用过django里面的modle层，以及对sql的理解
- orm
    >对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。django里面的自带的model层，完美的实现了orm的思想
    1. 优点
        专用、庞大的数据库访问层可能不再需要、提高效率
        像操作对象一样提取数据
    2. 缺点
        固定思维模式、牺牲执行效率
        很有可能将全部数据提取到内存对象中，大量消耗内存
- 原生sql
    > 就是我们所接触的sql语句。
    1. 优点
        灵活，可以根据自己的业务，灵活定义sql语句
        执行速度快，不用像orm再执行一层
    2. 缺点
        不可重用
        操作繁琐

## 3. 关于数据库问题
1. 数据库如何查看sql执行效率
- 查看执行时间
    ```
    1. 进入数据库，开启查看开关  set profiling = 1
    2. 执行自己的sql语句
    3. show profiles；就可以查到sql语句的执行时间
    ```
- 查看执行结果
    ```
    1. 在sql语句前面加上 explain就可以了
    2. 得到结果以后，会有很多字段，其中type字段是很重要的指标
    结果值从好到坏依次是：

    null>system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

    一般来说，得保证查询至少达到range级别，最好能达到ref

    ```
2. sql语句如何进行优化

    ```
    1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引
    2. 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描
    3. 应尽量避免在 where 子句中使用 or 来连接条件
    4. in 和 not in 也要慎用，否则会导致全表扫描
    5. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能
    6. 尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空
    7. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table
    8. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除
    9. ....
    ```

4. 符合索引的使用原则

   ```
   1. 最佳左前缀
   2. 尽量不要用in
   3. 不用用 !
   4. 不要和非索引字段使用 or
   ```


3. Mysql的三范式和五大约束

    ```
    第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；

    第二范式：满足1后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情

    第三范式：必须先满足第二范式，要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）

    1.primary KEY:设置主键约束；
    2.UNIQUE：设置唯一性约束，不能有重复值；
    3.DEFAULT 默认值约束
    4.NOT NULL：设置非空约束，该字段不能为空；
    5.FOREIGN key :设置外键约束。

## 4. 关于服务器部署或运营的问题

1. 服务器部署优化
    ```
    1. 采用缓存
    2. 采用分布式
    3. 采用nginx分发
    ```


"站长工具"

2. 关于访问量问题  网络营销->网络推广
    ```
    1、pv访问量（Page View），即页面访问量，每打开一次页面PV计数+1，刷新页面也是。

    2、UV访问数（Unique Visitor）指独立访客访问数，一台电脑终端为一个访客。

    3、IV是IP访问数指独立IP访问数，计算是以一个独立的IP在一个计算时段内访问网站计算为1次IP访问数。在同一个计算时段内不管这个IP访问多少次均计算为1次。计算时段有以1天为一个计算时段，也有以1个小时为一个计算时段。
    ```
